<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>Aggregating Event Emitter</h1><p>This is an event emitter that works similar to standard event emitters, but is purpose built to use events for getting
data as well as simply notifying parts of the system of events. This is helpful for invertion-of-control approaches
where you don't necessarily know what will be able to provide your code with the data you need, only that it will
exist at runtime.</p>
<p>In addition to this it has useful features like wildcard matching and list item matching.</p>
<h3>Installation</h3><pre class="prettyprint source lang-sh"><code>npm install aggregating-event-emitter</code></pre><h3>Usage examples</h3><p>Getting data returned by event handlers:</p>
<pre class="prettyprint source lang-js"><code>// Handler.js
const dataEvents = require('aggregating-event-emitter').aggregatingEventEmitter({ name: 'data', wildcards: true });
const data = {
    namespace: [1, 4, 9, 12]
};
dataEvents.on('*.data.get', (event, query) => {
    if (query.$gt) {
        const name = event.eventName.split('.')[0];
        return (data[name] || []).filter(value => value > query.$gt);
    }
});

// Emitter.js
// We can reference the previously instantiated event emitter by name and don't need to provide other options to it.
const dataEvents = require('aggregating-event-emitter').aggregatingEventEmitter({ name: 'data' });
const data = dataEvents.emit('namespace.data.get', { $gt: 5 });
console.log(data); // [[9, 12]]</code></pre><p>Waterfall:</p>
<pre class="prettyprint source lang-js"><code>const events = require('aggregating-event-emitter').aggregatingEventEmitter();

// These event handlers will be fired in this order and the output of the first will be passed to the input of the second.
events.on('my-event', (event, array) => array.map(value => value + 10));
events.on('my-event', (event, array) => array.map(value => value * 2));

const data = events.emitWaterfall('my-event', [0, 5, 10]);
console.log(data); // [20, 30, 40]</code></pre><p>Be aware that it's fully possible for one handler to break the data structure for another handler if you are not careful when
using the waterfall functions. In order to mitigate this, it may be worth using hooks to ensure the order is appropriate.</p>
<h1>API</h1><p>The API docs are available here: https://alcumus.github.io/aggregating-event-emitter/</p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="EventEmitter.html">EventEmitter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#aggregatingEventEmitter">aggregatingEventEmitter</a></li><li><a href="global.html#AggregatingEventEmitter">AggregatingEventEmitter</a></li><li><a href="global.html#removeNamedEventEmitter">removeNamedEventEmitter</a></li><li><a href="global.html#removeNamedEventEmitters">removeNamedEventEmitters</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Apr 09 2019 14:48:51 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>